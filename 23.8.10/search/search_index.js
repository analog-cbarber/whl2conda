var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Generate conda packages directly from pure python wheels</p> <p>whl2conda is a command line utility to build and test conda packages generated directly from pure python wheels.</p>"},{"location":"index.html#features","title":"Features","text":"<ul> <li> <p>Performance: because it does not need to create conda environments     for building, this is much faster than solutions involving conda-build.</p> </li> <li> <p>Multiple package formats: can generate both V1 ('.tar.bz2') and V2 ('.conda')     conda package formats. Can also generate a unpacked directory tree for debugging     or additional user customization.</p> </li> <li> <p>Dependency renaming: renames pypi package dependencies to their      corresponding conda name. Automatically renames packages from known     list collected from conda-forge and supports user-specified rename     patterns as well.</p> </li> <li> <p>Project configuration: project-specific options can be saved in     project's <code>pyproject.toml</code> file.</p> </li> <li> <p>Install support: supports installing conda package into a conda     environment for testing prior to deployment.</p> </li> <li> <p>Hides pypi dependencies: if the original pypi dependencies are included in     the python dist-info included in the conda package, this can result in      problems if pip or other python packaging tools are used in the conda environment.     To avoid this, whl2conda changes these dependencies to extras.</p> </li> </ul>"},{"location":"basic-usage.html","title":"Basic Usage","text":""},{"location":"basic-usage.html#converting-an-existing-wheel","title":"Converting an existing wheel","text":"<p>To convert an existing Python wheel to a conda package, you only need to  run <code>whl2conda convert</code>:</p> <pre><code>$ whl2conda convert mypackage-1.2.3-py3-none-any.whl\nReading mypackage-1.2.3-py3-none-any.whl\nWriting mypackage-1.2.3-py_0.coda\n</code></pre> <p>By default, this will create the conda package in the same directory as the wheel. You can specify a different output directory using the <code>--out-dir</code>, e.g.:</p> <pre><code>$ whl2conda convert mypackage-1.2.3-py3-none-any.whl --out-dir conda-dist\n</code></pre> <p>This will automatically convert pypi package dependencies to their corresponding conda package, renaming them as needed. Standard pypi/conda name mappings are taken from conda-forge. This will do the right thing for most packages, but you may also need to provide your own dependency rules to modify the dependencies. This is described in the section on Dependency Modification</p>"},{"location":"basic-usage.html#downloading-wheels","title":"Downloading wheels","text":"<p>If you want to create a conda package for a pure pytyhon package on pypi that doesn't currently have one available on a public channel, you can download the wheel using pip download. You do not need to download depenences and do not want an sdist, e.g.</p> <pre><code>$ pip download --only-binary:all: --no-deps some-package\n</code></pre> <p>Then you can convert the downloaded wheel using <code>whl2conda convert</code>.</p>"},{"location":"basic-usage.html#building-from-project-directories","title":"Building from project directories","text":"<p>If you are creating a conda package for your own python project that uses either a <code>pyproject.toml</code> file or a <code>setup.py</code> file, you can specify the project directory instead of a wheel file, or you can omit the positional argument if the project is located in the current working directory.</p> <pre><code>$ whl2conda convert my-project/\n</code></pre> <p>When run this way, there must be a <code>pyproject.toml</code> or <code>setup.py</code> file  in the directory. If there isa <code>pyrpoject.toml</code> file, whl2conda will read any project-specific options from the <code>[tool.whl2conda]</code> section (see Configuring pyproject.toml for details) and will then look for a wheel in the <code>dist/</code> subdirectory of the project.</p> <p>If there is only one <code>.whl</code> file in the <code>dist/</code> directory, that will be used. Otherwise, if the there is an interactive terminal and the  <code>--batch</code> option  has not been specified, whl2conda will prompt the user to choose a wheel or to build one using pip wheel.</p> <p>You can use the <code>--build-wheel</code> option to force the wheel to be built without prompting. So you can build both your project's wheel and a conda package non-interactively using the command:</p> <pre><code>$ whl2conda convert my-project/ --build-wheel --batch --yes\n</code></pre>"},{"location":"basic-usage.html#output-formats","title":"Output formats","text":"<p>By default, <code>whl2conda convert</code> will generate a V2 format file with a <code>.conda</code> extension.  If you instead want the old V1 format, which uses the <code>.tar.bz2</code> extension, you can use the <code>--format</code> option:</p> <pre><code>$ whl2conda convert mypackage-1.2.3-py3-none-any.whl --format V1\nReading mypackage-1.2.3-py3-none-any.whl\nWriting mypackage-1.2.3-py_0.tar.bz2\n</code></pre> <p>You can also specify the format <code>tree</code> to generate the conda package as a directory tree, so that you can examine its contents for debugging purposes.</p>"},{"location":"changelog.html","title":"whl2conda changes","text":""},{"location":"changelog.html#23810-2023-9-16-prerelease","title":"[23.8.10] - 2023-9-16 (prerelease)","text":"<ul> <li>Fix generation of entry points</li> <li>Adjust metadata generation</li> <li>Add <code>whl2conda diff</code> subcommand</li> </ul>"},{"location":"changelog.html#2389-2023-9-14-prerelease","title":"[23.8.9] - 2023-9-14 (prerelease)","text":"<ul> <li>Support <code>python -m whl2conda</code></li> <li>Fix issue with license copying</li> </ul>"},{"location":"changelog.html#2388-2023-9-10-prerelease","title":"[23.8.8] - 2023-9-10 (prerelease)","text":"<ul> <li>hide pip build wheel output with <code>--quiet</code></li> </ul>"},{"location":"changelog.html#2387-2023-9-9-prerelease","title":"[23.8.7] - 2023-9-9 (prerelease)","text":"<ul> <li>first conda-forge release</li> </ul>"},{"location":"install.html","title":"Installation","text":""},{"location":"install.html#using-pip","title":"Using pip","text":"<pre><code>pip install whl2conda\n</code></pre>"},{"location":"install.html#using-conda","title":"Using conda","text":"<pre><code>conda install -c conda-forge whl2conda\n</code></pre> <p>whl2conda does not have a direct runtime dependency on conda, so it is safe to install in environments other than <code>base</code>.</p>"},{"location":"install.html#prerequisites","title":"Prerequisites","text":"<p>It is assumed that you have installed conda, and that it is in the program path, but it is currently only required for <code>whl2conda install</code>. Furthermore, if you use the <code>--conda-bld</code> option, you must have <code>conda-index</code> installed in your base environment (you will already have it if you have <code>conda-build</code>).</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"{}\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright 2023   Christopher Barber</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"limitations.html","title":"Limitations","text":"<p>whl2conda currently only supports conversion of generic pure python wheels into noarch python conda packages.</p> <p>It has the following limitations, some of which will be addressed in future releases.</p>"},{"location":"limitations.html#version-specifiers-are-not-translated","title":"Version specifiers are not translated","text":"<p>Version specifiers in dependencies are simply copied from the wheel without modification. This works for many cases, but since the version comparison operators for pip and conda are slightly different, some version specifiers will not work properly in conda. Specifically,</p> <ul> <li> <p>the compatible release operator <code>~=</code> is not supported by conda.     To translate, use a double expression with <code>&gt;=</code> and <code>*</code>, e.g.:     <code>~= 1.2.3</code> would become <code>&gt;=1.2.3,1.2.*</code> in conda. This form is     also supported by pip, so this is a viable workaround for packages     you control.</p> </li> <li> <p>the arbitrary equality clause <code>===</code> is not supported by conda.     I do not believe there is an equivalent to this in conda, but     this clause is also heavily discouraged in dependencies and     might not even match the corresponding conda package.</p> </li> </ul> <p>(There are other operations supported by conda but not pip, but the are not a concern when translating from pip specifiers.)</p> <p>As a workaround, users can switch to compatible specifier syntax when possible and otherwise can remove the offending package and add it back with compatible specifier syntax, e.g.:</p> <pre><code>whl2conda mywheel-1.2.3-py3-none-any.whl -D foo -A 'foo &gt;=1.2.3,1.2.*'\n</code></pre> <p>This will be fixed in a future release  (see issue 84).</p>"},{"location":"limitations.html#wheel-data-directories-not-supported","title":"Wheel data directories not supported","text":"<p>Wheels with <code>*.data</code> directies are not fully supported. Any such data directories will not be copied.</p> <p>This will be addressed in a future release (see issue 91)</p>"},{"location":"limitations.html#cannot-convert-from-sdist","title":"Cannot convert from sdist","text":"<p>Currently, only conversion from wheels is supported. Conversion from python sdist distributions are not currently supported. This could possibly be supported in  the future (see issue 78).</p>"},{"location":"limitations.html#cannot-convert-from-eggs","title":"Cannot convert from eggs","text":"<p>Python egg files  are also not supported. Since this file format is deprecated and  uploads to pypi are no longer allowed, we have no plans to support this format.</p>"},{"location":"limitations.html#cannot-handle-dependencies-using-extras","title":"Cannot handle dependencies using extras","text":"<p>Currently, for any dependencies that declare extras, the extras dependencies are not included. For instance, the dependency:</p> <pre><code>black[jupyter]\n</code></pre> <p>will include the <code>black</code> dependency itself, but not any extra dependencies that are declared with the <code>extra == 'jupyter'</code> marker. This will be addressed in a future release. See issue 36.</p>"},{"location":"limitations.html#only-supports-noarch-python","title":"Only supports noarch python","text":"<p>Currently, only generic python conda packages with <code>noarch: python</code> will be generated.</p> <p>In the future we might be able to allow <code>noarch: python</code> packages with a pinned python version (see issue 50) and architecture-specific python packages that do not have a pinned python version (see issue 51).</p>"},{"location":"limitations.html#cannot-handle-dependencies-with-environment-markers","title":"Cannot handle dependencies with environment markers","text":"<p>Currently, dependencies with environment markers are not included in the conda package. Instead, they could conditionally be included in an OS-specific package (as mentioned above).</p>"},{"location":"limitations.html#pure-python-only","title":"Pure python only","text":"<p>whl2conda does not support wheels with binary content. </p>"},{"location":"links.html","title":"Reference Material","text":""},{"location":"links.html#conda","title":"Conda","text":"<ul> <li>conda file format</li> <li>package spec</li> <li>conda-package-handling tool (cph)</li> </ul>"},{"location":"links.html#wheels","title":"Wheels:","text":"<ul> <li>Binary distribution format</li> <li>Recording installed packages</li> <li>Current meta-data specification</li> <li>Wheel 1.0 file format (PEP 427)</li> <li>Wheel metadata 1.0 (PEP 241)</li> <li>Wheel metadata 1.1 (PEP 314)</li> <li>Wheel metadata 1.2 (PEP 345)</li> <li>Wheel metadata 2.1 (PEP 566)</li> </ul>"},{"location":"links.html#pyprojecttoml-metadata-format","title":"pyproject.toml metadata format:","text":"<ul> <li>Current specification</li> <li>PEP 621</li> <li>PEP 639 - license files</li> <li>PEP 725 - external dependencies</li> </ul>"},{"location":"links.html#poetry-issues","title":"Poetry issues:","text":"<ul> <li>Poetry PEP 621 support</li> </ul>"},{"location":"pyproject.html","title":"Configuring pyproject.toml","text":"<p>If you are working with a project using a <code>pyproject.toml</code> file, you can add configuration options for whl2conda in the <code>[tool.whl2conda]</code> section of the file rather than using command line options.</p> <p>The easiest way to start with these options, is to generate default options with comments using:</p> <pre><code>$ whl2conda config --generate-pyproject my-project-dir/\n</code></pre> <p>This is safe to use on an existing pyproject file and will not  overwrite any existing options.</p> <p>The available options are described below.</p>"},{"location":"pyproject.html#pyprojecttoml-options","title":"pyproject.toml options","text":""},{"location":"pyproject.html#conda-name","title":"conda-name","text":"<p>Overrides name of conda package generated by whl2conda. If empty, default is taken from project.name.</p> <p>This is overriden by the <code>--name</code> convert option.</p>"},{"location":"pyproject.html#wheel-dir","title":"wheel-dir","text":"<p>The default directory for whl2conda to look for wheels. Specified relative to the project root. If not specified, defaults to 'dist'.</p> <p>Overridden by the <code>--wheel-dir</code> convert option.</p>"},{"location":"pyproject.html#out-dir","title":"out-dir","text":"<p>The default directory for writing conda packages. If not specified, this will be the wheel directory.</p> <p>Overridden by the <code>--out-dir</code> convert option.</p>"},{"location":"pyproject.html#conda-format","title":"conda-format","text":"<p>The default output conda package format. Valid values are:</p> <ul> <li><code>\"V1\"</code> / <code>\".tar.bz2\"</code>: original .tar.bz2 package forma</li> <li><code>\"V2\"</code> / <code>\".conda\"</code>: new V2 .conda package format',</li> <li><code>\"TREE\"</code>:  output package as directory tree (debug)',</li> </ul> <p>Overriddenn by the <code>--format</code> convert option.</p>"},{"location":"pyproject.html#dependency-rename","title":"dependency-rename","text":"<p>An optional list of pypi/conda rename patterns. Each entry should be a two element list of the form:</p> <pre><code>   [\"&lt;pypi-name-pattern&gt;\", \"&lt;conda-name&gt;\"]',\n</code></pre> <p>Where <code>&lt;pypi-name-pattern&gt;</code> may either just be the pypi package name or is a Python regular expression that will match the full name, and where  can contain subsitution expression, For example, to rename all <code>acme-&lt;foo&gt;</code> packages to <code>acme.&lt;foo&gt;</code>: <pre><code>   [\"acme-(.*)\", \"acme.$1\"]\n</code></pre>"},{"location":"pyproject.html#extra-dependencies","title":"extra-dependencies","text":"<p>An optional list of extra conda dependencies.</p>"},{"location":"renaming.html","title":"Dependency Modification","text":""},{"location":"renaming.html#overview","title":"Overview","text":"<p>Python packages found on pypi.org and installed using pip often have the same name as packages found on anaconda.org and installed using conda. For instance, you can install <code>pylint</code> using:</p> pipconda <pre><code>$ pip install pylint\n</code></pre> <pre><code>$ conda install -c conda-forge pylint\n</code></pre> <p>But pypi and conda are actually totally separate packaging systems and there is no inherent requirement that package names match, and indeed there are some exceptions, for example:</p> pipconda <pre><code>$ pip install numpy-quaternion \n$ pip install tables\n$ pip install torch\n</code></pre> <pre><code>$ conda install -c conda-forge quaternion \n$ conda install -c conda-forge pytables\n$ conda install -c conda-forge pytorch\n</code></pre> <p>So when converting from wheels to conda packages, it is important that these differences be handled by the tool.</p>"},{"location":"renaming.html#standard-renames","title":"Standard renames","text":"<p>The whl2conda tool maintains a table of automatic renaming rules that is taken from mappings collected aumatically from tools supporting the public conda-forge repository. whl2conda includes a static copy of this table collated when whl2conda was built, but also supports the ability to maintain and update a locally cached copy dynmically. If there is package new to conda-forge that may have appeared since installing whl2conda, you can update your local cache using:</p> <pre><code>$ whl2conda --update-std-renames\n</code></pre> <p>The cache file is kept in a location in your user directory that is specific  to your operating system:</p> <ul> <li>Linux: <code>~/.cache/whl2conda/stdrename.json</code></li> <li>MacOS: <code>~/Library/Caches/whl2conda/stdrename.json</code></li> <li>Windows: <code>~\\AppData\\Local\\whl2conda\\Cache\\stdrename.json</code></li> </ul> <p>This file is simply a JSON dictionary mapping pypi names to conda names.</p> <p>If you want to generate a copy of this file in another location (e.g. for use by other development tools), you can add a path to the <code>---update-std-renames</code> option:</p> <pre><code>$ whl2conda --update-std-renames pypi-conda-renames.json\n</code></pre>"},{"location":"renaming.html#manual-rules","title":"Manual rules","text":"<p>The implicit standard renaming support takes care of most renaming issues for publicly available packages, but may not work for packages that come from alternative channels, which may be private to your organization.</p> <p>If you encounter these, you can add command line options to with <code>whl2conda convert</code> to rename packages and also to add or drop packages. You may also rename the package you are building.</p>"},{"location":"renaming.html#adding-extra-packages","title":"Adding extra packages","text":"<p>You can add one or more extra package dependencies using the <code>-A</code> / <code>--add-depencency</code> option. This can be a conda package name and version spec, e.g.:</p> <pre><code>$ whl2conda -A 'extra-package &gt;=1.2.3' ...\n</code></pre> <p>You can use this to add dependencies for conda packages that perhaps do not exist on pypi.</p>"},{"location":"renaming.html#dropping-a-package","title":"Dropping a package","text":"<p>Likewise, you can drop packages using <code>-D</code> / <code>--drop-dependency</code> with just the package name:</p> <pre><code>$ whl2conda -D 'some-pypi-only-package'\n</code></pre> <p>This option also allows you to use python regular expressions to drop any package that matches a pattern:</p> <pre><code>$ whl2conda -D 'acme-.*'\n</code></pre>"},{"location":"renaming.html#renaming-dependencies","title":"Renaming dependencies","text":"<p>To rename dependencies, use <code>-R</code> / <code>--dependency-rename</code> with two arguments, the pypi name followed by the conda name.  You can also use regular expressions with capture groups, where <code>$&lt;n&gt;</code> will be replaced with the nth capture and <code>${name}</code> will be replaced with the named capture group with given name.</p> plainregular expressionnamed regular expression <pre><code>$ whl2conda -R acme-widgets acme.widgets\n</code></pre> <pre><code>$ whl2conda -R 'acme-(.*)' 'acme.$1'\n</code></pre> <pre><code>$ whl2conda -R 'acme-(?P&lt;part&gt;.*)' 'acme.${part}'\n</code></pre>"},{"location":"renaming.html#renaming-converted-package","title":"Renaming converted package","text":"<p>By default, the name of the generated conda package will be taken from the project name in the <code>pyproject.toml</code> if there is one, otherwise from the name in the wheel. This can be overriden using the <code>--name</code> command line option:</p> <pre><code>$ whl2conda acme-widgets-1.2.3-py3-None-any.whl --name acme-pywidgets\n</code></pre>"},{"location":"renaming.html#specifying-rules-in-pyprojecttoml-file","title":"Specifying rules in pyproject.toml file","text":"<p>If you are using a <code>pyproject.toml</code> file for your project, you can instead specify how dependencies are modified in the tool options. This is described in the next section.</p>"},{"location":"renaming.html#hiding-pip-dependencies-in-dist-info-directory-for-conda","title":"Hiding pip dependencies in dist-info directory for conda","text":"<p>We have sometimes seen problems in packages built using conda-build in which the pip dependencies listed in the python packages dist-info directory in the site-packages directory in the conda environment where the conda package is installed can clash with conda dependencies. To avoid this kind of problem, the <code>whl2conda</code> by default will turn all regular dependencies in the dist-info into extra dependencies using the name <code>original</code>. So if you look at the <code>METADATA</code> file in the dist-info of the generated conda package, you will see entries like:</p> <pre><code>Requires-Dist: some-package &gt;=1.2; extra == 'original'\n</code></pre> <p>If you want to leave these dependencies unchanged you can use the <code>--keep-pip-dependencies</code> option to <code>whl2conda convert</code>. This is  not recommended unless you know that you need them.</p>"},{"location":"support.html","title":"Getting help","text":"<ul> <li>Ask a question</li> <li>Look at open issues (before opening a bug or feature request)</li> <li>Report a bug</li> <li>Make a feature request</li> <li>Use the Source, Luke...</li> </ul>"},{"location":"testing.html","title":"Installing and Testing","text":""},{"location":"testing.html#installing-into-a-test-environment","title":"Installing into a test environment","text":"<p>You will probably want to test your generated conda package before deploying it. Currently, <code>conda install</code> only supports installing conda package files without their dependencies, so <code>whl2conda</code> provides an <code>install</code> subcommand to install a package into a test environment along with its dependencies:</p> <pre><code>$ whl2conda install mypackage-1.2.3-py_0.conda -n test-env\n</code></pre> <p>If you want to create an environment in a temporary directory:</p> <pre><code>$ whl2conda install mypackage-1.2.3-py_0.conda --create -p tmp-dir\n</code></pre> <p>You can also add additional dependencies or other options to pass to the underlying <code>conda install</code> command:</p> <pre><code>$ whl2conda install mypackage-1.2.3-py_0.conda \\\n--create -p tmp-dir \\\n--extra pytest -c my-channel\n</code></pre>"},{"location":"testing.html#installing-into-conda-bld","title":"Installing into conda-bld","text":"<p>Once you are done testing, you may either upload your package to a conda channel using the approriate tool (e.g. <code>anaconda upload</code> or <code>curl</code>). Or you may want to install into your local conda-bld directory to support <code>conda install --use-local</code>. You can do this using:</p> <pre><code>$ whl2conda install mypackage-1.2.3-py_0.conda --conda-bld\n</code></pre>"},{"location":"testing.html#comparing-packages","title":"Comparing packages","text":"<p>You may wish to compare generated packages against those generated by conda-build in order both to understand what this tool is doing and to verify that nothing important is missing. You can do this using the <code>whl2conda diff</code> command with your favorite directory diff tool. This will unpack the packages into temporary directories, normalize the metadata files to minimize mismatches and run the specified diff tool with the given arguments.</p> <p>For instance,</p> <pre><code>$ whl2conda diff \\\ndist/mypackage-1.2.3-py_0.conda \\\n~/miniforge3/conda-bld/noarch/mypackage-1.2.3-py_90.tar.bz2 \\\nkdiff3\n</code></pre> <p>Note that some differences are expected in the <code>info/</code> directory, specifically:</p> <ul> <li>packages generated with whl2conda will not have copy of the recipe    or test directory</li> <li>the about.json file may differ</li> <li>the timestamp will be different in the <code>index.json</code> file</li> <li>the <code>paths.json</code> file should reflect any files that differ</li> </ul> <p>There are also expected to be changes in the <code>site-packages/*dist-info/</code> for the package:</p> <ul> <li>the <code>INSTALLER</code> file will contain <code>whl2conda</code> instead of <code>conda</code></li> <li>the <code>Requires-Dist</code> entries in <code>METADATA</code> will be modified to add     <code>; extra = 'original'</code></li> </ul>"},{"location":"api/converter.html","title":"whl2conda.api.converter","text":"<p>Converter API</p>"},{"location":"api/converter.html#whl2conda.api.converter-classes","title":"Classes","text":""},{"location":"api/converter.html#whl2conda.api.converter.CondaPackageFormat","title":"CondaPackageFormat","text":"<p>             Bases: <code>Enum</code></p> <p>Supported output package formats</p> <ul> <li>V1: original conda format as .tar.bz2 file</li> <li>V2: newer .conda format</li> <li>TREE: dumps package out as a directory tree (for debugging)</li> </ul> Source code in <code>src/whl2conda/impl/pyproject.py</code> <pre><code>class CondaPackageFormat(enum.Enum):\n\"\"\"\n    Supported output package formats\n\n    * V1: original conda format as .tar.bz2 file\n    * V2: newer .conda format\n    * TREE: dumps package out as a directory tree (for debugging)\n    \"\"\"\n\n    V1 = \".tar.bz2\"\n    V2 = \".conda\"\n    TREE = \".tree\"\n\n    @classmethod\n    def from_string(cls, name: str) -&gt; CondaPackageFormat:\n\"\"\"Convert string to CondaPackageFormat\n\n        Arguments:\n            name: either the enum name or a file extension, i.e.\n                \"V1\"/\".tar.bz2\", \"V2\"/\".conda\", or \"TREE\"\n        \"\"\"\n        try:\n            return cls[name.upper()]\n        except LookupError:\n            return cls(name.lower())\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter.CondaPackageFormat-functions","title":"Functions","text":""},{"location":"api/converter.html#whl2conda.api.converter.CondaPackageFormat.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(name: str) -&gt; CondaPackageFormat\n</code></pre> <p>Convert string to CondaPackageFormat</p> PARAMETER  DESCRIPTION <code>name</code> <p>either the enum name or a file extension, i.e. \"V1\"/\".tar.bz2\", \"V2\"/\".conda\", or \"TREE\"</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/whl2conda/impl/pyproject.py</code> <pre><code>@classmethod\ndef from_string(cls, name: str) -&gt; CondaPackageFormat:\n\"\"\"Convert string to CondaPackageFormat\n\n    Arguments:\n        name: either the enum name or a file extension, i.e.\n            \"V1\"/\".tar.bz2\", \"V2\"/\".conda\", or \"TREE\"\n    \"\"\"\n    try:\n        return cls[name.upper()]\n    except LookupError:\n        return cls(name.lower())\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter.DependencyRename","title":"DependencyRename","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Defines a pypi to conda package renaming rule.</p> <p>The pattern must fully match the input package. The replacement string may contain group references e.g. r'\\1', r'\\g`. Source code in <code>src/whl2conda/api/converter.py</code> <pre><code>class DependencyRename(NamedTuple):\nr\"\"\"\n    Defines a pypi to conda package renaming rule.\n\n    The pattern must fully match the input package.\n    The replacement string may contain group references\n    e.g. r'\\1', r'\\g&lt;name&gt;`.\n    \"\"\"\n\n    pattern: re.Pattern\n    replacement: str\n\n    @classmethod\n    def from_strings(cls, pattern: str, replacement: str) -&gt; DependencyRename:\nr\"\"\"Construct from strings\n\n        This will also translate '$#' and '${name}' expressions\n        into r'\\#' and r'\\P&lt;name&gt;' respectively.\n        \"\"\"\n        try:\n            pat = re.compile(pattern)\n        except re.error as err:\n            # pylint: disable=raise-missing-from\n            raise ValueError(f\"Bad dependency rename pattern '{pattern}': {err}\")\n        repl = re.sub(r\"\\$(\\d+)\", r\"\\\\\\1\", replacement)\n        repl = re.sub(r\"\\$\\{(\\w+)}\", r\"\\\\g&lt;\\1&gt;\", repl)\n        # TODO also verify replacement does not contain invalid package chars\n        try:\n            pat.sub(repl, \"\")\n        except Exception as ex:\n            if isinstance(ex, re.error):\n                msg = ex.msg\n            else:\n                msg = str(ex)\n            # pylint: disable=raise-missing-from\n            raise ValueError(\n                f\"Bad dependency replacement '{replacement}' for pattern '{pattern}': {msg}\"\n            )\n        return cls(pat, repl)\n\n    def rename(self, pypi_name: str) -&gt; tuple[str, bool]:\n\"\"\"Rename dependency package name\n\n        Returns conda name and indicator of whether the\n        pattern was applied.\n        \"\"\"\n        if m := self.pattern.fullmatch(pypi_name):\n            return m.expand(self.replacement), True\n        return pypi_name, False\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter.DependencyRename-functions","title":"Functions","text":""},{"location":"api/converter.html#whl2conda.api.converter.DependencyRename.from_strings","title":"from_strings  <code>classmethod</code>","text":"<pre><code>from_strings(\n    pattern: str, replacement: str\n) -&gt; DependencyRename\n</code></pre> <p>Construct from strings</p> <p>This will also translate '$#' and '${name}' expressions into r'#' and r'\\P' respectively. Source code in <code>src/whl2conda/api/converter.py</code> <pre><code>@classmethod\ndef from_strings(cls, pattern: str, replacement: str) -&gt; DependencyRename:\nr\"\"\"Construct from strings\n\n    This will also translate '$#' and '${name}' expressions\n    into r'\\#' and r'\\P&lt;name&gt;' respectively.\n    \"\"\"\n    try:\n        pat = re.compile(pattern)\n    except re.error as err:\n        # pylint: disable=raise-missing-from\n        raise ValueError(f\"Bad dependency rename pattern '{pattern}': {err}\")\n    repl = re.sub(r\"\\$(\\d+)\", r\"\\\\\\1\", replacement)\n    repl = re.sub(r\"\\$\\{(\\w+)}\", r\"\\\\g&lt;\\1&gt;\", repl)\n    # TODO also verify replacement does not contain invalid package chars\n    try:\n        pat.sub(repl, \"\")\n    except Exception as ex:\n        if isinstance(ex, re.error):\n            msg = ex.msg\n        else:\n            msg = str(ex)\n        # pylint: disable=raise-missing-from\n        raise ValueError(\n            f\"Bad dependency replacement '{replacement}' for pattern '{pattern}': {msg}\"\n        )\n    return cls(pat, repl)\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter.DependencyRename.rename","title":"rename","text":"<pre><code>rename(pypi_name: str) -&gt; tuple[str, bool]\n</code></pre> <p>Rename dependency package name</p> <p>Returns conda name and indicator of whether the pattern was applied.</p> Source code in <code>src/whl2conda/api/converter.py</code> <pre><code>def rename(self, pypi_name: str) -&gt; tuple[str, bool]:\n\"\"\"Rename dependency package name\n\n    Returns conda name and indicator of whether the\n    pattern was applied.\n    \"\"\"\n    if m := self.pattern.fullmatch(pypi_name):\n        return m.expand(self.replacement), True\n    return pypi_name, False\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter.MetadataFromWheel","title":"MetadataFromWheel  <code>dataclass</code>","text":"<p>Metadata parsed from wheel distribution</p> Source code in <code>src/whl2conda/api/converter.py</code> <pre><code>@dataclass\nclass MetadataFromWheel:\n\"\"\"Metadata parsed from wheel distribution\"\"\"\n\n    md: dict[str, Any]\n    package_name: str\n    version: str\n    wheel_build_number: str\n    license: Optional[str]\n    dependencies: list[RequiresDistEntry]\n    wheel_info_dir: Path\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter.RequiresDistEntry","title":"RequiresDistEntry  <code>dataclass</code>","text":"<p>Requires-Dist metadata entry parsed from wheel</p> Source code in <code>src/whl2conda/api/converter.py</code> <pre><code>@dataclass\nclass RequiresDistEntry:\n\"\"\"\n    Requires-Dist metadata entry parsed from wheel\n    \"\"\"\n\n    # see https://packaging.python.org/specifications/core-metadata/#requires-dist-multiple-use\n    # and https://peps.python.org/pep-0508/\n    name: str\n    extras: Sequence[str] = ()\n    version: str = \"\"\n    marker: str = \"\"\n\n    extra_marker_name: str = \"\"\n\"\"\"Name from extra expression in marker, if any\"\"\"\n\n    generic: bool = True\n\"\"\"True if marker is empty or only contains an extra expression\"\"\"\n\n    @classmethod\n    def parse(cls, raw: str) -&gt; RequiresDistEntry:\n\"\"\"\n        Parse entry from raw string read from \"Requires-Dist\" or related header.\n\n        Raises:\n            SyntaxError: if entry is not properly formatted.\n        \"\"\"\n        m = _requires_dist_re.fullmatch(raw)\n        if not m:\n            raise SyntaxError(f\"Cannot parse Requires-Dist entry: {repr(raw)}\")\n        entry = RequiresDistEntry(name=m.group(\"name\"))\n        if extra := m.group(\"extra\"):\n            entry.extras = tuple(re.split(r\"\\s*,\\s*\", extra))\n        if version := m.group(\"version\"):\n            entry.version = version\n        if marker := m.group(\"marker\"):\n            entry.marker = marker\n            entry.generic = False\n            for pat in _extra_marker_re:\n                if m := pat.search(marker):\n                    entry.extra_marker_name = m.group(\"name\")\n                    if m.string == marker:\n                        entry.generic = True\n                    break\n        return entry\n\n    def __str__(self) -&gt; str:\n        with io.StringIO() as buf:\n            buf.write(self.name)\n            if self.extras:\n                buf.write(f\" [{','.join(self.extras)}]\")\n            if self.version:\n                buf.write(f\" {self.version}\")\n            if self.marker:\n                buf.write(f\" ; {self.marker}\")\n            return buf.getvalue()\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter.RequiresDistEntry-attributes","title":"Attributes","text":""},{"location":"api/converter.html#whl2conda.api.converter.RequiresDistEntry.extra_marker_name","title":"extra_marker_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra_marker_name: str = ''\n</code></pre> <p>Name from extra expression in marker, if any</p>"},{"location":"api/converter.html#whl2conda.api.converter.RequiresDistEntry.generic","title":"generic  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>generic: bool = True\n</code></pre> <p>True if marker is empty or only contains an extra expression</p>"},{"location":"api/converter.html#whl2conda.api.converter.RequiresDistEntry-functions","title":"Functions","text":""},{"location":"api/converter.html#whl2conda.api.converter.RequiresDistEntry.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(raw: str) -&gt; RequiresDistEntry\n</code></pre> <p>Parse entry from raw string read from \"Requires-Dist\" or related header.</p> RAISES DESCRIPTION <code>SyntaxError</code> <p>if entry is not properly formatted.</p> Source code in <code>src/whl2conda/api/converter.py</code> <pre><code>@classmethod\ndef parse(cls, raw: str) -&gt; RequiresDistEntry:\n\"\"\"\n    Parse entry from raw string read from \"Requires-Dist\" or related header.\n\n    Raises:\n        SyntaxError: if entry is not properly formatted.\n    \"\"\"\n    m = _requires_dist_re.fullmatch(raw)\n    if not m:\n        raise SyntaxError(f\"Cannot parse Requires-Dist entry: {repr(raw)}\")\n    entry = RequiresDistEntry(name=m.group(\"name\"))\n    if extra := m.group(\"extra\"):\n        entry.extras = tuple(re.split(r\"\\s*,\\s*\", extra))\n    if version := m.group(\"version\"):\n        entry.version = version\n    if marker := m.group(\"marker\"):\n        entry.marker = marker\n        entry.generic = False\n        for pat in _extra_marker_re:\n            if m := pat.search(marker):\n                entry.extra_marker_name = m.group(\"name\")\n                if m.string == marker:\n                    entry.generic = True\n                break\n    return entry\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter.Wheel2CondaConverter","title":"Wheel2CondaConverter","text":"<p>Converter supports generation of conda package from a pure python wheel.</p> Source code in <code>src/whl2conda/api/converter.py</code> <pre><code>class Wheel2CondaConverter:\n\"\"\"\n    Converter supports generation of conda package from a pure python wheel.\n\n    \"\"\"\n\n    SUPPORTED_WHEEL_VERSIONS = (\"1.0\",)\n    SUPPORTED_METADATA_VERSIONS = (\"1.0\", \"1.1\", \"1.2\", \"2.1\", \"2.2\", \"2.3\")\n    MULTI_USE_METADATA_KEYS = {\n        \"Classifier\",\n        \"Dynamic\",\n        \"License-File\",\n        \"Obsoletes\",\n        \"Obsoletes-Dist\",\n        \"Platform\",\n        \"Project-URL\",\n        \"Provides\",\n        \"Provides-Dist\",\n        \"Provides-Extra\",\n        \"Requires\",\n        \"Requires-Dist\",\n        \"Requires-External\",\n        \"Supported-Platform\",\n    }\n\n    package_name: str = \"\"\n    logger: logging.Logger\n    wheel_path: Path\n    out_dir: Path\n    dry_run: bool = False\n    wheel: Optional[WheelFile]\n    out_format: CondaPackageFormat\n    overwrite: bool = False\n    keep_pip_dependencies: bool = False\n    dependency_rename: list[DependencyRename]\n    extra_dependencies: list[str]\n    interactive: bool = False\n    build_number: Optional[int] = None\n\n    wheel_md: Optional[MetadataFromWheel] = None\n    conda_pkg_path: Optional[Path] = None\n    std_renames: dict[str, str]\n\n    temp_dir: Optional[tempfile.TemporaryDirectory] = None\n\n    def __init__(\n        self,\n        wheel_path: Path,\n        out_dir: Path,\n    ):\n        self.logger = logging.getLogger(__name__)\n        self.wheel_path = wheel_path\n        self.out_dir = out_dir\n        self.dependency_rename = []\n        self.extra_dependencies = []\n        # TODO - option to ignore this\n        self.std_renames = load_std_renames()\n\n    def __enter__(self):\n        self.temp_dir = tempfile.TemporaryDirectory(prefix=\"whl2conda-\")\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.temp_dir:\n            self.temp_dir.cleanup()\n\n    def convert(self) -&gt; Path:\n\"\"\"\n        Convert wheel to conda package\n\n        Does not write any non-temporary files if dry_run is True.\n\n        Returns:\n            Path of conda package\n        \"\"\"\n        # pylint: disable=too-many-statements,too-many-branches,too-many-locals\n\n        with self:\n            assert self.temp_dir is not None\n\n            extracted_wheel_dir = self._extract_wheel()\n\n            wheel_md = self._parse_wheel_metadata(extracted_wheel_dir)\n\n            conda_dir = Path(self.temp_dir.name).joinpath(\"conda-files\")\n            conda_info_dir = conda_dir.joinpath(\"info\")\n            conda_dir.mkdir()\n\n            # Copy files into site packages and get relative paths\n            rel_files = self._copy_site_packages(extracted_wheel_dir, conda_dir)\n\n            conda_dependencies = self._compute_conda_dependencies(wheel_md.dependencies)\n\n            # Write conda info files\n            # TODO - copy readme file into info\n            #  must be one of README, README.md or README.rst\n            self._copy_licenses(conda_info_dir, wheel_md)\n            self._write_about(conda_info_dir, wheel_md.md)\n            self._write_hash_input(conda_info_dir)\n            self._write_files_list(conda_info_dir, rel_files)\n            self._write_index(conda_info_dir, wheel_md, conda_dependencies)\n            self._write_link_file(conda_info_dir, wheel_md.wheel_info_dir)\n            self._write_paths_file(conda_dir, rel_files)\n            self._write_git_file(conda_info_dir)\n\n            conda_pkg_path = self._conda_package_path(\n                wheel_md.package_name, wheel_md.version\n            )\n            self._write_conda_package(conda_dir, conda_pkg_path)\n\n            return conda_pkg_path\n\n    def _conda_package_path(self, package_name: str, version: str) -&gt; Path:\n\"\"\"Construct conda package file path\"\"\"\n        if self.out_format is CondaPackageFormat.TREE:\n            suffix = \"\"\n        else:\n            suffix = str(self.out_format.value)\n        conda_pkg_file = f\"{package_name}-{version}-py_0{suffix}\"\n        self.conda_pkg_path = Path(self.out_dir).joinpath(conda_pkg_file)\n        return self.conda_pkg_path\n\n    # pylint: disable=too-many-branches\n    def _write_conda_package(self, conda_dir: Path, conda_pkg_path: Path) -&gt; Path:\n        dry_run_suffix = \" (dry run)\" if self.dry_run else \"\"\n        if self.logger.getEffectiveLevel() &lt;= logging.DEBUG:\n            for file in conda_dir.glob(\"**/*\"):\n                if file.is_file():\n                    self._debug(\"Packaging %s\", file.relative_to(conda_dir))\n        if conda_pkg_path.exists():\n            if not self.overwrite:\n                msg = f\"Output conda package already exists at '{conda_pkg_path}'\"\n                overwrite = False\n                if self.interactive:\n                    print(msg)\n                    overwrite = bool_input(\"Overwrite? \")\n                if not overwrite:\n                    raise FileExistsError(msg)\n            self._info(\"Removing existing %s%s\", conda_pkg_path, dry_run_suffix)\n            if not self.dry_run:\n                if conda_pkg_path.is_dir():\n                    shutil.rmtree(conda_pkg_path)\n                else:\n                    conda_pkg_path.unlink()\n        self._info(\"Writing %s%s\", conda_pkg_path, dry_run_suffix)\n\n        if not self.dry_run:\n            if self.out_format is CondaPackageFormat.TREE:\n                shutil.copytree(\n                    conda_dir, Path(self.out_dir).joinpath(conda_pkg_path.name)\n                )\n            else:\n                self.out_dir.mkdir(parents=True, exist_ok=True)\n                create_conda_pkg(conda_dir, None, conda_pkg_path.name, self.out_dir)\n\n        return conda_pkg_path\n\n    def _write_git_file(self, conda_info_dir: Path) -&gt; None:\n\"\"\"Write empty git file\"\"\"\n        # python wheels don't have this concept, but conda-build\n        # will write an empty git file if there are no git sources,\n        # so we follow suit:\n        conda_info_dir.joinpath(\"git\").write_bytes(b'')\n\n    def _write_paths_file(self, conda_dir: Path, rel_files: Sequence[str]) -&gt; None:\n        # info/paths.json - paths with SHA256 do we really need this?\n        conda_paths_file = conda_dir.joinpath(\"info\", \"paths.json\")\n        paths: list[dict[str, Any]] = []\n        for rel_file in rel_files:\n            abs_file = conda_dir.joinpath(rel_file)\n            file_bytes = abs_file.read_bytes()\n            paths.append(\n                dict(\n                    _path=rel_file,\n                    path_type=\"hardlink\",\n                    sha256=sha256(file_bytes).hexdigest(),\n                    size_in_bytes=len(file_bytes),\n                )\n            )\n        conda_paths_file.write_text(\n            json.dumps(dict(paths=paths, paths_version=1), indent=2)\n        )\n\n    def _write_link_file(self, conda_info_dir: Path, wheel_info_dir: Path) -&gt; None:\n        # info/link.json\n        conda_link_file = conda_info_dir.joinpath(\"link.json\")\n        wheel_entry_points_file = wheel_info_dir.joinpath(\"entry_points.txt\")\n        console_scripts: list[str] = []\n        if wheel_entry_points_file.is_file():\n            wheel_entry_points = configparser.ConfigParser()\n            wheel_entry_points.read(wheel_entry_points_file)\n            for section_name in [\"console_scripts\", \"gui_scripts\"]:\n                if section_name in wheel_entry_points:\n                    if section := wheel_entry_points[section_name]:\n                        console_scripts.extend(f\"{k}={v}\" for k, v in section.items())\n        noarch_dict: dict[str, Any] = dict(type=\"python\")\n        if console_scripts:\n            noarch_dict[\"entry_points\"] = console_scripts\n        conda_link_file.write_text(\n            json.dumps(\n                dict(\n                    noarch=noarch_dict,\n                    package_metadata_version=1,\n                ),\n                indent=2,\n                sort_keys=True,\n            )\n        )\n\n    # pylint: disable=too-many-arguments\n    def _write_index(\n        self,\n        conda_info_dir: Path,\n        wheel_md: MetadataFromWheel,\n        conda_dependencies: Sequence[str],\n    ) -&gt; None:\n        # info/index.json\n        conda_index_file = conda_info_dir.joinpath(\"index.json\")\n\n        if self.build_number is not None:\n            build_number = self.build_number\n        else:\n            try:\n                build_number = int(wheel_md.wheel_build_number)\n            except ValueError:\n                build_number = 0\n\n        conda_index_file.write_text(\n            json.dumps(\n                dict(\n                    arch=None,\n                    build=\"py_0\",\n                    build_number=build_number,\n                    depends=conda_dependencies,\n                    license=wheel_md.license,\n                    name=wheel_md.package_name,\n                    noarch=\"python\",\n                    platform=None,\n                    subdir=\"noarch\",\n                    timestamp=int(time.time() + time.timezone),  # UTC timestamp\n                    version=wheel_md.version,\n                ),\n                indent=2,\n            )\n        )\n\n    def _write_files_list(self, conda_info_dir: Path, rel_files: Sequence[str]) -&gt; None:\n        # * info/files - list of relative paths of files not including info/\n        conda_files_file = conda_info_dir.joinpath(\"files\")\n        with open(conda_files_file, \"w\") as f:\n            for rel_file in rel_files:\n                f.write(str(rel_file))\n                f.write(\"\\n\")\n\n    def _write_hash_input(self, conda_info_dir: Path) -&gt; None:\n        conda_hash_input_file = conda_info_dir.joinpath(\"hash_input.json\")\n        conda_hash_input_file.write_text(json.dumps({}, indent=2))\n\n    # pylint: disable=too-many-locals\n    def _write_about(self, conda_info_dir: Path, md: dict[str, Any]) -&gt; None:\n        # * info/about.json\n        #\n        # Note that the supported fields in the about section are not\n        # well documented, but conda-build will only copy fields from\n        # its approved list, which can be found in the FIELDS datastructure\n        # in the conda_build.metadata module. This currently includes:\n        #\n        #   URLS: home, dev_url, doc_url, doc_source_url\n        #   Text: license, summary, description, license_family\n        #   Lists: tags, keyword\n        #   Paths in source tree: license-file, prelink_message, readme\n        #\n        # conda-build also adds conda-build-version and conda-version fields.\n\n        license = md.get(\"license-expression\") or md.get(\"license\")\n        conda_about_file = conda_info_dir.joinpath(\"about.json\")\n        # TODO description can come from METADATA message body\n        #   then need to also use content type. It doesn't seem\n        #   that conda-forge packages include this in the info/\n        doc_url: Optional[str] = None\n        dev_url: Optional[str] = None\n        extra: dict[str, Any] = non_none_dict(\n            author=md.get(\"author\"),\n            classifiers=md.get(\"classifier\"),\n            maintainer=md.get(\"maintainer\"),\n            whl2conda_version=__version__,\n        )\n        for urlline in md.get(\"project-url\", ()):\n            urlparts = re.split(r\"\\s*,\\s*\", urlline, maxsplit=1)\n            if len(urlparts) &gt; 1:\n                key, url = urlparts\n                keyl = key.lower()\n                if re.match(r\"doc(umentation)?\\b\", keyl):\n                    doc_url = urlparts[1]\n                elif re.match(r\"(dev(elopment)?|repo(sitory))\\b\", keyl):\n                    dev_url = urlparts[1]\n                if key and url:\n                    extra[key] = url\n        for key in [\"author-email\", \"maintainer-email\"]:\n            val = md.get(key)\n            if val:\n                author_key = key.split(\"-\", maxsplit=1)[0] + \"s\"\n                extra[author_key] = val.split(\",\")\n        if license_files := md.get(\"license-file\"):\n            extra[\"license_files\"] = list(license_files)\n        if keywords := md.get(\"keywords\"):\n            keyword_list = keywords.split(\",\")\n        else:\n            keyword_list = None\n        conda_about_file.write_text(\n            json.dumps(\n                non_none_dict(\n                    description=md.get(\"description\"),\n                    summary=md.get(\"summary\"),\n                    license=license or None,\n                    keywords=keyword_list,\n                    home=md.get(\"home-page\"),\n                    dev_url=dev_url,\n                    doc_url=doc_url,\n                    extra=extra or None,\n                ),\n                indent=2,\n            )\n        )\n\n    # pylint: disable=too-many-locals\n    def _compute_conda_dependencies(\n        self,\n        dependencies: Sequence[RequiresDistEntry],\n    ) -&gt; list[str]:\n        conda_dependencies: list[str] = []\n\n        # TODO - instead RequiresDistEntrys should be passed as an argument\n\n        for entry in dependencies:\n            if entry.extra_marker_name:\n                self._debug(\"Skipping extra dependency: %s\", entry)\n                continue\n            if not entry.generic:\n                # TODO - support non-generic packages\n                self._warn(\"Skipping dependency with environment marker: %s\", entry)\n                continue\n\n            conda_name = pip_name = entry.name\n            version = entry.version\n            # TODO - do something with extras (#36)\n            #   download target pip package and its extra dependencies\n            # check manual renames first\n            renamed = False\n            for renamer in self.dependency_rename:\n                conda_name, renamed = renamer.rename(pip_name)\n                if renamed:\n                    break\n            if not renamed:\n                conda_name = self.std_renames.get(pip_name, pip_name)\n\n            if conda_name:\n                conda_dep = f\"{conda_name} {version}\"\n                if conda_name == pip_name:\n                    self._debug(\"Dependency copied: '%s'\", conda_dep)\n                else:\n                    self._debug(\"Dependency renamed: '%s' -&gt; '%s'\", entry, conda_dep)\n                conda_dependencies.append(conda_dep)\n            else:\n                self._debug(\"Dependency dropped: %s\", entry)\n        for dep in self.extra_dependencies:\n            self._debug(\"Dependency added:  '%s'\", dep)\n            conda_dependencies.append(dep)\n        return conda_dependencies\n\n    def _copy_site_packages(self, wheel_dir: Path, conda_dir: Path) -&gt; list[str]:\n        conda_site_packages = conda_dir.joinpath(\"site-packages\")\n        conda_site_packages.mkdir()\n        conda_info_dir = conda_dir.joinpath(\"info\")\n        conda_info_dir.mkdir()\n        shutil.copytree(wheel_dir, conda_site_packages, dirs_exist_ok=True)\n        assert self.wheel_md is not None\n        dist_info_dir = conda_site_packages / self.wheel_md.wheel_info_dir.name\n        installer_file = dist_info_dir / \"INSTALLER\"\n        installer_file.write_text(\"whl2conda\")\n        requested_file = dist_info_dir / \"REQUESTED\"\n        requested_file.write_text(\"\")\n        rel_files = list(\n            str(f.relative_to(conda_dir))\n            for f in conda_site_packages.glob(\"**/*\")\n            if f.is_file()\n        )\n        return rel_files\n\n    def _copy_licenses(self, conda_info_dir: Path, wheel_md: MetadataFromWheel) -&gt; None:\n        to_license_dir = conda_info_dir / \"licenses\"\n        wheel_info_dir = wheel_md.wheel_info_dir\n        wheel_license_dir = wheel_info_dir / \"licenses\"\n        if wheel_license_dir.is_dir():\n            # just copy directory\n            shutil.copytree(\n                wheel_license_dir,\n                to_license_dir,\n                dirs_exist_ok=True,\n            )\n        else:\n            # Otherwise look for files in the dist-info dir\n            # that match the license-file entries. The paths\n            # of the license-file entries may be relative to\n            # where the wheel was built and may not directly\n            # point at the files.\n            for license_file in wheel_md.md.get(\"license-file\", ()):\n                # copy license file if it exists\n                license_path = Path(license_file)\n                from_files = [wheel_info_dir / license_path.name]\n                if not license_path.is_absolute():\n                    from_files.insert(0, wheel_info_dir / license_path)\n                for from_file in from_files:\n                    if from_file.exists():\n                        to_file = to_license_dir / from_file.relative_to(wheel_info_dir)\n                        if not to_file.exists():\n                            to_file.parent.mkdir(parents=True, exist_ok=True)\n                            shutil.copyfile(from_file, to_file)\n                            break\n\n    # pylint: disable=too-many-locals, too-many-statements\n    def _parse_wheel_metadata(self, wheel_dir: Path) -&gt; MetadataFromWheel:\n        wheel_info_dir = next(wheel_dir.glob(\"*.dist-info\"))\n        WHEEL_file = wheel_info_dir.joinpath(\"WHEEL\")\n        WHEEL_msg = email.message_from_string(WHEEL_file.read_text(\"utf8\"))\n        # https://peps.python.org/pep-0427/#what-s-the-deal-with-purelib-vs-platlib\n\n        is_pure_lib = WHEEL_msg.get(\"Root-Is-Purelib\", \"\").lower() == \"true\"\n        wheel_build_number = WHEEL_msg.get(\"Build\", \"\")\n        wheel_version = WHEEL_msg.get(\"Wheel-Version\")\n\n        if wheel_version not in self.SUPPORTED_WHEEL_VERSIONS:\n            raise Wheel2CondaError(\n                f\"Wheel {self.wheel_path} has unsupported wheel version {wheel_version}\"\n            )\n\n        if not is_pure_lib:\n            raise Wheel2CondaError(f\"Wheel {self.wheel_path} is not pure python\")\n\n        wheel_md_file = wheel_info_dir.joinpath(\"METADATA\")\n        md: dict[str, list[Any]] = {}\n        # Metdata spec: https://packaging.python.org/en/latest/specifications/core-metadata/\n        # Required keys: Metadata-Version, Name, Version\n        md_msg = email.message_from_string(wheel_md_file.read_text())\n        md_version_str = md_msg.get(\"Metadata-Version\")\n        if md_version_str not in self.SUPPORTED_METADATA_VERSIONS:\n            # TODO - perhaps just warn about this if not in \"strict\" mode\n            raise Wheel2CondaError(\n                f\"Wheel {self.wheel_path} has unsupported metadata version {md_version_str}\"\n            )\n        # md_version = tuple(int(x) for x in md_version_str.split(\".\"))\n        for mdkey, mdval in md_msg.items():\n            mdkey = mdkey.strip()\n            if mdkey in self.MULTI_USE_METADATA_KEYS:\n                md.setdefault(mdkey.lower(), []).append(mdval)\n            else:\n                md[mdkey.lower()] = mdval\n            if mdkey in {\"requires-dist\", \"requires\"}:\n                continue\n\n        requires: list[RequiresDistEntry] = []\n        raw_requires_entries = md.get(\"requires-dist\", md.get(\"requires\", ()))\n        for raw_entry in raw_requires_entries:\n            try:\n                entry = RequiresDistEntry.parse(raw_entry)\n                requires.append(entry)\n            except SyntaxError as err:\n                # TODO: error in strict mode?\n                self._warn(str(err))\n\n        if not self.keep_pip_dependencies:\n            # Turn requirements into optional extra requirements\n            del md_msg[\"Requires\"]\n            del md_msg[\"Requires-Dist\"]\n            for entry in requires:\n                if not entry.extra_marker_name:\n                    marker = entry.marker\n                    extra_clause = \"extra == 'original'\"\n                    if marker:\n                        marker = f\"({entry.marker}) and {extra_clause}\"\n                    else:\n                        marker = extra_clause\n                    entry = dataclasses.replace(entry, marker=marker)\n                md_msg.add_header(\"Requires-Dist\", str(entry))\n            md_msg.add_header(\"Provides-Extra\", \"original\")\n            wheel_md_file.write_text(md_msg.as_string())\n        package_name = self.package_name or str(md.get(\"name\"))\n        self.package_name = package_name\n        version = md.get(\"version\")\n\n        # RECORD_file = wheel_info_dir / \"RECORD\"\n        # TODO: strip __pycache__ entries from RECORD\n        # TODO: add INSTALLER and REQUESTED to RECORD\n        # TODO: add direct_url to wheel and to RECORD\n        # RECORD line format: &lt;path&gt;,sha256=&lt;hash&gt;,&lt;len&gt;\n\n        python_version: str = str(md.get(\"requires-python\", \"\"))\n        if python_version:\n            requires.append(RequiresDistEntry(\"python\", version=python_version))\n        self.wheel_md = MetadataFromWheel(\n            md=md,\n            package_name=package_name,\n            version=str(version),\n            wheel_build_number=wheel_build_number,\n            license=md.get(\"license-expression\") or md.get(\"license\"),  # type: ignore\n            dependencies=requires,\n            wheel_info_dir=wheel_info_dir,\n        )\n        return self.wheel_md\n\n    def _extract_wheel(self) -&gt; Path:\n        self.logger.info(\"Reading %s\", self.wheel_path)\n        wheel = WheelFile(self.wheel_path)\n        assert self.temp_dir\n        wheel_dir = Path(self.temp_dir.name).joinpath(\"wheel-files\")\n        wheel.extractall(wheel_dir)\n        if self.logger.getEffectiveLevel() &lt;= logging.DEBUG:\n            for wheel_file in wheel_dir.glob(\"**/*\"):\n                if wheel_file.is_file():\n                    self._debug(\"Extracted %s\", wheel_file.relative_to(wheel_dir))\n        return wheel_dir\n\n    def _warn(self, msg, *args):\n        self.logger.warning(msg, *args)\n\n    def _info(self, msg, *args):\n        self.logger.info(msg, *args)\n\n    def _debug(self, msg, *args):\n        self.logger.debug(msg, *args)\n\n    def _trace(self, msg, *args):\n        self.logger.log(logging.DEBUG - 5, msg, *args)\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter.Wheel2CondaConverter-functions","title":"Functions","text":""},{"location":"api/converter.html#whl2conda.api.converter.Wheel2CondaConverter.convert","title":"convert","text":"<pre><code>convert() -&gt; Path\n</code></pre> <p>Convert wheel to conda package</p> <p>Does not write any non-temporary files if dry_run is True.</p> RETURNS DESCRIPTION <code>Path</code> <p>Path of conda package</p> Source code in <code>src/whl2conda/api/converter.py</code> <pre><code>def convert(self) -&gt; Path:\n\"\"\"\n    Convert wheel to conda package\n\n    Does not write any non-temporary files if dry_run is True.\n\n    Returns:\n        Path of conda package\n    \"\"\"\n    # pylint: disable=too-many-statements,too-many-branches,too-many-locals\n\n    with self:\n        assert self.temp_dir is not None\n\n        extracted_wheel_dir = self._extract_wheel()\n\n        wheel_md = self._parse_wheel_metadata(extracted_wheel_dir)\n\n        conda_dir = Path(self.temp_dir.name).joinpath(\"conda-files\")\n        conda_info_dir = conda_dir.joinpath(\"info\")\n        conda_dir.mkdir()\n\n        # Copy files into site packages and get relative paths\n        rel_files = self._copy_site_packages(extracted_wheel_dir, conda_dir)\n\n        conda_dependencies = self._compute_conda_dependencies(wheel_md.dependencies)\n\n        # Write conda info files\n        # TODO - copy readme file into info\n        #  must be one of README, README.md or README.rst\n        self._copy_licenses(conda_info_dir, wheel_md)\n        self._write_about(conda_info_dir, wheel_md.md)\n        self._write_hash_input(conda_info_dir)\n        self._write_files_list(conda_info_dir, rel_files)\n        self._write_index(conda_info_dir, wheel_md, conda_dependencies)\n        self._write_link_file(conda_info_dir, wheel_md.wheel_info_dir)\n        self._write_paths_file(conda_dir, rel_files)\n        self._write_git_file(conda_info_dir)\n\n        conda_pkg_path = self._conda_package_path(\n            wheel_md.package_name, wheel_md.version\n        )\n        self._write_conda_package(conda_dir, conda_pkg_path)\n\n        return conda_pkg_path\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter.Wheel2CondaError","title":"Wheel2CondaError","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Errors from Wheel2CondaConverter</p> Source code in <code>src/whl2conda/api/converter.py</code> <pre><code>class Wheel2CondaError(RuntimeError):\n\"\"\"Errors from Wheel2CondaConverter\"\"\"\n</code></pre>"},{"location":"api/converter.html#whl2conda.api.converter-functions","title":"Functions","text":""},{"location":"api/converter.html#whl2conda.api.converter.non_none_dict","title":"non_none_dict","text":"<pre><code>non_none_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>dict that drops keys with None values</p> Source code in <code>src/whl2conda/api/converter.py</code> <pre><code>def non_none_dict(**kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"dict that drops keys with None values\"\"\"\n    d = dict()\n    for k, v in kwargs.items():\n        if v is not None:\n            d[k] = v\n    return d\n</code></pre>"},{"location":"api/stdrename.html","title":"whl2conda.api.stdrename","text":"<p>Support for standard pypi to conda renames drawn from conda-forge.</p> <p>There are files generated automatically by conda-forge bots that include information about pypi/conda package names. These are available from:</p> <p>https://github.com/regro/cf-graph-countyfair/blob/master/mappings/pypi</p> <p>This package provides utility functions for downlaading mappings from that site and extracting a standard pypi to conda name mapping dictionary.</p> <p>NOTE: this module should not be considered stable! The API may change incompatibly in a future release.</p>"},{"location":"api/stdrename.html#whl2conda.api.stdrename-attributes","title":"Attributes","text":""},{"location":"api/stdrename.html#whl2conda.api.stdrename.DEFAULT_MIN_EXPIRATION","title":"DEFAULT_MIN_EXPIRATION  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MIN_EXPIRATION = 300\n</code></pre> <p>Default minimum expiration in seconds for cached renames</p>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.NAME_MAPPINGS_DOWNLOAD_URL","title":"NAME_MAPPINGS_DOWNLOAD_URL  <code>module-attribute</code>","text":"<pre><code>NAME_MAPPINGS_DOWNLOAD_URL = (\n    f\"{RAW_MAPPINGS_URL}/{NAME_MAPPINGS_FILENAME}\"\n)\n</code></pre> <p>URL from which automatically generated pypi to conda name mappings are downloaded.</p>"},{"location":"api/stdrename.html#whl2conda.api.stdrename-classes","title":"Classes","text":""},{"location":"api/stdrename.html#whl2conda.api.stdrename.DownloadedMappings","title":"DownloadedMappings","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Holds downloaded mapping table from github with HTTP headers.</p> Source code in <code>src/whl2conda/api/stdrename.py</code> <pre><code>class DownloadedMappings(NamedTuple):\n\"\"\"\n    Holds downloaded mapping table from github with HTTP headers.\n    \"\"\"\n\n    url: str\n    headers: email.message.EmailMessage\n    mappings: Sequence[NameMapping]\n\n    @property\n    def date(self) -&gt; Optional[datetime.datetime]:\n\"\"\"Date from header\"\"\"\n        return parse_datetime(self.datestr)\n\n    @property\n    def datestr(self) -&gt; str:\n\"\"\"Date string from header\"\"\"\n        return self.headers.get(\"Date\", \"\")\n\n    @property\n    def etag(self) -&gt; str:\n\"\"\"ETag string from header\"\"\"\n        return self.headers.get(\"ETag\", \"\").strip('\"')\n\n    @property\n    def expires(self) -&gt; Optional[datetime.datetime]:\n\"\"\"Expires date string frome header\"\"\"\n        return parse_datetime(self.headers.get(\"Expires\", \"\"))\n\n    @property\n    def max_age(self) -&gt; int:\n\"\"\"Max age from Cache-Control header\n\n        Max age in seconds from cache control header, or\n        else difference between [expires][..] and [date][..] or else -1.\n        \"\"\"\n        if cc := self.headers.get(\"Cache-Control\", \"\"):\n            if m := re.search(r\"max-age=(\\d+)\", cc):\n                return int(m.group(1))\n        if expires := self.expires:\n            date = self.date or datetime.datetime.now(datetime.timezone.utc)\n            return (expires - date).seconds\n        return -1\n</code></pre>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.DownloadedMappings-attributes","title":"Attributes","text":""},{"location":"api/stdrename.html#whl2conda.api.stdrename.DownloadedMappings.date","title":"date  <code>property</code>","text":"<pre><code>date: Optional[datetime.datetime]\n</code></pre> <p>Date from header</p>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.DownloadedMappings.datestr","title":"datestr  <code>property</code>","text":"<pre><code>datestr: str\n</code></pre> <p>Date string from header</p>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.DownloadedMappings.etag","title":"etag  <code>property</code>","text":"<pre><code>etag: str\n</code></pre> <p>ETag string from header</p>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.DownloadedMappings.expires","title":"expires  <code>property</code>","text":"<pre><code>expires: Optional[datetime.datetime]\n</code></pre> <p>Expires date string frome header</p>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.DownloadedMappings.max_age","title":"max_age  <code>property</code>","text":"<pre><code>max_age: int\n</code></pre> <p>Max age from Cache-Control header</p> <p>Max age in seconds from cache control header, or else difference between expires and date or else -1.</p>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.NameMapping","title":"NameMapping","text":"<p>             Bases: <code>TypedDict</code></p> <p>Expected format of github name_mapping.json table</p> Source code in <code>src/whl2conda/api/stdrename.py</code> <pre><code>class NameMapping(TypedDict):\n\"\"\"Expected format of github name_mapping.json table\"\"\"\n\n    pypi_name: str\n    conda_name: str\n    import_name: str\n</code></pre>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.NotModified","title":"NotModified","text":"<p>             Bases: <code>HTTPError</code></p> <p>Indicates content was not modified</p> Source code in <code>src/whl2conda/api/stdrename.py</code> <pre><code>class NotModified(HTTPError):  # pylint: disable=too-many-ancestors\n\"\"\"Indicates content was not modified\"\"\"\n</code></pre>"},{"location":"api/stdrename.html#whl2conda.api.stdrename-functions","title":"Functions","text":""},{"location":"api/stdrename.html#whl2conda.api.stdrename.download_mappings","title":"download_mappings","text":"<pre><code>download_mappings(\n    url: str = NAME_MAPPINGS_DOWNLOAD_URL,\n    *,\n    etag: str = \"\",\n    timeout: float = 20.0\n) -&gt; DownloadedMappings\n</code></pre> <p>Download pypi to conda name mappings from github</p> PARAMETER  DESCRIPTION <code>url</code> <p>download url of mappings file on github</p> <p> TYPE: <code>str</code> DEFAULT: <code>NAME_MAPPINGS_DOWNLOAD_URL</code> </p> <code>etag</code> <p>ETag from previous download</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>timeout</code> <p>max seconds to wait for connection</p> <p> TYPE: <code>float</code> DEFAULT: <code>20.0</code> </p> RETURNS DESCRIPTION <code>DownloadedMappings</code> <p>Mapping table and HTTP headers.</p> RAISES DESCRIPTION <code>NotModified</code> <p>if etag was specified and content has not changed</p> <code>HttpError</code> <p>other HTTP errors (e.g. 404 etc)</p> <code>URLError</code> <p>connection errors</p> Source code in <code>src/whl2conda/api/stdrename.py</code> <pre><code>def download_mappings(\n    url: str = NAME_MAPPINGS_DOWNLOAD_URL,\n    *,\n    etag: str = \"\",\n    timeout: float = 20.0,\n) -&gt; DownloadedMappings:\n\"\"\"\n    Download pypi to conda name mappings from github\n\n    Args:\n        url: download url of mappings file on github\n        etag: ETag from previous download\n        timeout: max seconds to wait for connection\n\n    Returns:\n        Mapping table and HTTP headers.\n\n    Raises:\n        NotModified: if etag was specified and content has not changed\n        HttpError: other HTTP errors (e.g. 404 etc)\n        URLError: connection errors\n    \"\"\"\n\n    req = urllib.request.Request(\n        url,\n        headers={\"User-Agent\": f\"whl2conda/{__version__}\"},\n    )\n    if etag:\n        req.add_header(\"If-None-Match\", f'\"{etag}\"')\n\n    try:\n        with urllib.request.urlopen(req, timeout=timeout) as response:\n            headers = response.headers\n            content = response.read()\n            mappings = json.loads(content)\n    except HTTPError as err:\n        if err.status == HTTPStatus.NOT_MODIFIED:  # type: ignore\n            raise NotModified(\n                url,\n                err.code,\n                err.reason,\n                err.headers,\n                err.fp,\n            ) from err\n        raise\n\n    return DownloadedMappings(url, headers, mappings)\n</code></pre>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.load_std_renames","title":"load_std_renames","text":"<pre><code>load_std_renames(*, update: bool = False) -&gt; dict[str, str]\n</code></pre> <p>Load standard pypi to conda package rename table.</p> <p>A copy of this table is kept in a local a cache file (see user_stdrenames_path) The table will be read from that file, it it exists, otherwise the table included in this package will be copied to the user cache file.</p> PARAMETER  DESCRIPTION <code>update</code> <p>if true, this will update the table from online list generated from conda-forge and saves it as the new cached copy.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Dictionary of pypi to conda package name mappings. The</p> <code>dict[str, str]</code> <p>returned dictionary will also contain the entries \"$etag\",</p> <code>dict[str, str]</code> <p>\"$date\" and \"$source\" taken from the downloaded web file</p> <code>dict[str, str]</code> <p>from which it was computed.</p> Source code in <code>src/whl2conda/api/stdrename.py</code> <pre><code>def load_std_renames(\n    *,\n    update: bool = False,\n) -&gt; dict[str, str]:\n\"\"\"\n    Load standard pypi to conda package rename table.\n\n    A copy of this table is kept in a local a cache\n    file (see [user_stdrenames_path][(m).])\n    The table will be read from that file, it it exists, otherwise the\n    table included in this package will be copied to the\n    user cache file.\n\n    Arguments:\n        update: if true, this will update the table from online\n            list generated from conda-forge and saves it as the\n            new cached copy.\n\n    Returns:\n        Dictionary of pypi to conda package name mappings. The\n        returned dictionary will also contain the entries \"$etag\",\n        \"$date\" and \"$source\" taken from the downloaded web file\n        from which it was computed.\n    \"\"\"\n    # Look for local copy of stdrenames\n    local_std_rename_file = user_stdrenames_path()\n    if not local_std_rename_file.exists():\n        # pylint: disable=no-member\n        if sys.version_info &gt;= (3, 9):  # pragma: no cover\n            resources = importlib.resources.files('whl2conda.api')\n            s = resources.joinpath(\"stdrename.json\").read_text(\"utf8\")\n        else:  # pragma: no cover\n            s = importlib.resources.read_text(\n                \"whl2conda.api\",\n                \"stdrename.json\",\n                encoding=\"utf\",\n            )\n        local_std_rename_file.parent.mkdir(parents=True, exist_ok=True)\n        local_std_rename_file.write_text(s, \"utf8\")\n\n    if update:\n        update_renames_file(local_std_rename_file)\n\n    s = local_std_rename_file.read_text(\"utf8\")\n    return json.loads(s)\n</code></pre>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.parse_datetime","title":"parse_datetime","text":"<pre><code>parse_datetime(s: str) -&gt; Optional[datetime.datetime]\n</code></pre> <p>Parse datetime string from HTTP header</p> <p>Returns None if string is empty or time is malformed.</p> Source code in <code>src/whl2conda/api/stdrename.py</code> <pre><code>def parse_datetime(s: str) -&gt; Optional[datetime.datetime]:\n\"\"\"Parse datetime string from HTTP header\n\n    Returns None if string is empty or time is malformed.\n    \"\"\"\n    try:\n        return parsedate_to_datetime(s)\n    except Exception:  # pylint: disable=broad-exception-caught\n        return None\n</code></pre>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.process_name_mapping_dict","title":"process_name_mapping_dict","text":"<pre><code>process_name_mapping_dict(\n    mappings: DownloadedMappings,\n) -&gt; dict[str, str]\n</code></pre> <p>Convert name mapping table from github to simple rename table.</p> <p>This only returns mappings where the name is different.</p> PARAMETER  DESCRIPTION <code>mappings</code> <p>downlaoded mappings</p> <p> TYPE: <code>DownloadedMappings</code> </p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>dictionary mapping pypi to conda package names</p> Source code in <code>src/whl2conda/api/stdrename.py</code> <pre><code>def process_name_mapping_dict(mappings: DownloadedMappings) -&gt; dict[str, str]:\n\"\"\"\n    Convert name mapping table from github to simple rename table.\n\n    This only returns mappings where the name is different.\n\n    Args:\n        mappings: downlaoded mappings\n\n    Returns:\n        dictionary mapping pypi to conda package names\n    \"\"\"\n    renames: dict[str, str] = {\n        \"$source\": mappings.url,\n        \"$date\": mappings.datestr or formatdate(usegmt=True),\n        \"$etag\": mappings.etag,\n        \"$max-age\": str(max(mappings.max_age, DEFAULT_MIN_EXPIRATION)),\n    }\n    for entry in mappings.mappings:\n        pypi_name = entry.get(\"pypi_name\")\n        conda_name = entry.get(\"conda_name\")\n        if pypi_name and conda_name and pypi_name != conda_name:\n            renames[pypi_name] = conda_name\n    return renames\n</code></pre>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.update_renames_file","title":"update_renames_file","text":"<pre><code>update_renames_file(\n    renames_file: Union[Path, str],\n    *,\n    url: str = NAME_MAPPINGS_DOWNLOAD_URL,\n    min_expiration: int = DEFAULT_MIN_EXPIRATION,\n    dry_run: bool = False\n) -&gt; bool\n</code></pre> <p>Update standard renames file from github if changed</p> <p>This will only download new data if the existing data has passed its expiration.</p> PARAMETER  DESCRIPTION <code>renames_file</code> <p>path to renames file, which does not have to exist initially</p> <p> TYPE: <code>Union[Path, str]</code> </p> <code>url</code> <p>url of name mapping file to download. This file is expected to contain a JSON array of dictionary containing \"pypi_name\" and \"conda_name\" entries.</p> <p> TYPE: <code>str</code> DEFAULT: <code>NAME_MAPPINGS_DOWNLOAD_URL</code> </p> <code>min_expiration</code> <p>minimum seconds before existing data expires. Default is 5 minutes.</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_MIN_EXPIRATION</code> </p> <code>dry_run</code> <p>does not update the file, but still does download and returns True if file would change</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if file was updated. False if file has not expired yet</p> <code>bool</code> <p>or upstream data has not changed.</p> Source code in <code>src/whl2conda/api/stdrename.py</code> <pre><code>def update_renames_file(\n    renames_file: Union[Path, str],\n    *,\n    url: str = NAME_MAPPINGS_DOWNLOAD_URL,\n    min_expiration: int = DEFAULT_MIN_EXPIRATION,\n    dry_run: bool = False,\n) -&gt; bool:\n\"\"\"\n    Update standard renames file from github if changed\n\n    This will only download new data if the existing\n    data has passed its expiration.\n\n    Args:\n        renames_file: path to renames file, which does not have to\n            exist initially\n        url: url of name mapping file to download. This file is\n            expected to contain a JSON array of dictionary\n            containing \"pypi_name\" and \"conda_name\" entries.\n        min_expiration: minimum seconds before existing data expires.\n            Default is 5 minutes.\n        dry_run: does not update the file, but still does download\n            and returns True if file would change\n\n    Returns:\n        True if file was updated. False if file has not expired yet\n        or upstream data has not changed.\n    \"\"\"\n    renames_path = Path(renames_file).expanduser()\n\n    etag = \"\"\n    if renames_path.is_file():\n        # check expiration information from existing file\n        current_renames = json.loads(renames_path.read_text(\"utf8\"))\n        if date := parse_datetime(current_renames.get(\"$date\", \"\")):\n            try:\n                max_age = int(current_renames.get(\"$max-age\", 0))\n            except Exception:  # pylint: disable=broad-exception-caught\n                max_age = 0\n            max_age = max(min_expiration, max_age)\n            if (date.timestamp() + max_age) &gt; time.time():\n                # Not expired yet\n                return False\n        etag = current_renames.get(\"$etag\")\n\n    try:\n        downloaded = download_mappings(url=url, etag=etag)\n    except NotModified:\n        return False\n\n    new_renames = process_name_mapping_dict(downloaded)\n    if not dry_run:\n        renames_path.parent.mkdir(parents=True, exist_ok=True)\n        renames_path.write_text(\n            json.dumps(new_renames, sort_keys=True, indent=2),\n            encoding=\"utf8\",\n        )\n\n    return True\n</code></pre>"},{"location":"api/stdrename.html#whl2conda.api.stdrename.user_stdrenames_path","title":"user_stdrenames_path","text":"<pre><code>user_stdrenames_path() -&gt; Path\n</code></pre> <p>Path to user's cached copy of standard pypi to conda renames file</p> <p>The location of this file depends on the operating system:</p> <ul> <li>Linux: ~/.cache/whl2conda/stdrename.json</li> <li>MacOS: ~/Library/Caches/whl2conda/stdrename.json</li> <li>Windows: ~\\AppData\\Local\\whl2conda\\Cache\\stdrename.json</li> </ul> Source code in <code>src/whl2conda/api/stdrename.py</code> <pre><code>def user_stdrenames_path() -&gt; Path:\nr\"\"\"Path to user's cached copy of standard pypi to conda renames file\n\n    The location of this file depends on the operating system:\n\n    * Linux: ~/.cache/whl2conda/stdrename.json\n    * MacOS: ~/Library/Caches/whl2conda/stdrename.json\n    * Windows: ~\\AppData\\Local\\whl2conda\\Cache\\stdrename.json\n    \"\"\"\n    return user_cache_path(\"whl2conda\").joinpath(\"stdrename.json\")\n</code></pre>"},{"location":"cli/whl2conda-config.html","title":"whl2conda config","text":""},{"location":"cli/whl2conda-config.html#whl2conda-config","title":"whl2conda config","text":""},{"location":"cli/whl2conda-config.html#usage","title":"Usage","text":"<pre><code>usage: whl2conda config [-h] [--generate-pyproject [&lt;dir-or-toml&gt;]]\n                        [--update-std-renames [&lt;file&gt;]] [-n]\n</code></pre> <p>whl2conda configuration</p>"},{"location":"cli/whl2conda-config.html#optional-arguments","title":"optional arguments","text":"<pre><code>  -h, --help\n            show this help message and exit\n  --generate-pyproject [&lt;dir-or-toml&gt;]\n            Add default whl2conda tool entries to a pyproject file. \n            If argument is a directory entries will be added to \n            `pyproject.toml` in that directory. If argument ends\n            with suffix '.toml', that file will be updated. If\n            the argument is omitted or set to `out` the generated entry \n            will be written to stdout. Other values will result in an error.\n            This will create file if it does not already exist.\n            It will not overwrite existing entires.\n  --update-std-renames [&lt;file&gt;]\n            Update list of standard pypi to conda renames from internet and exit.\n            If a &lt;file&gt; is not named, the default copy will be updated at\n            /Users/Christopher.Barber/Library/Caches/whl2conda/stdrename.json.\n  -n, --dry-run\n            Do not write any files.\n</code></pre>"},{"location":"cli/whl2conda-convert.html","title":"whl2conda convert","text":""},{"location":"cli/whl2conda-convert.html#whl2conda-convert","title":"whl2conda convert","text":""},{"location":"cli/whl2conda-convert.html#usage","title":"Usage","text":"<pre><code>usage: whl2conda convert &lt;wheel&gt; [options]\n       whl2conda convert [&lt;project-root&gt;] [options]\n</code></pre> <p>Generates a conda package from a pure python wheel</p>"},{"location":"cli/whl2conda-convert.html#input-options","title":"Input options","text":"<pre><code>  [&lt;wheel&gt; | &lt;project-root&gt;]\n            Either path to a wheel file to convert or a project root\n            directory containing a pyproject.toml or setup.py file.\n  --project-root &lt;dir&gt;, --root &lt;dir&gt;\n            Project root directory. This is a directory containing either a\n            pyproject.toml or a (deprecated) setup.py file. This option may\n            not be used if the project directory was given as the positional\n            argument.\n\n            If not specified, the project root will be located by searching\n            the wheel directory and its parent directories, or if no wheel\n            given, will default to the current directory.\n  -w &lt;dir&gt;, --wheel-dir &lt;dir&gt;\n            Location of wheel directory. Defaults to dist/ subdirectory of \n            project.\n  --ignore-pyproject\n            Ignore settings from pyproject.toml file, if any\n</code></pre>"},{"location":"cli/whl2conda-convert.html#output-options","title":"Output options","text":"<pre><code>  --out-dir &lt;dir&gt;, --out &lt;dir&gt;\n            Output directory for conda package. Defaults to wheel directory\n            or else project dist directory.\n  --overwrite\n            Overwrite existing output files.\n  --format {V1,tar.bz2,V2,conda,tree}, --out-format {V1,tar.bz2,V2,conda,tree}\n            Output package format (None)\n  --build-wheel\n            Build wheel\n  --build-number BUILD_NUMBER\n            Specify build number. Otherwise taken from wheel.\n</code></pre>"},{"location":"cli/whl2conda-convert.html#override-options","title":"Override options","text":"<pre><code>  --name &lt;package-name&gt;\n            Override package name\n  -R &lt;pip-name&gt; &lt;conda-name&gt;, --dependency-rename &lt;pip-name&gt; &lt;conda-name&gt;\n            Rename pip dependency for conda. May be specified muliple times.\n  -A &lt;conda-dep&gt;, --add-dependency &lt;conda-dep&gt;\n            Add an additional conda dependency. May be specified multiple times.\n  -D &lt;pip-name&gt;, --drop-dependency &lt;pip-name&gt;\n            Drop dependency with given name from conda dependency list.\n            May be specified multiple times.\n  -K, --keep-pip-dependencies\n            Retain pip dependencies in python dist_info of conda package.\n  --python &lt;version-spec&gt;\n            Set/override python dependency.\n</code></pre>"},{"location":"cli/whl2conda-convert.html#help-and-debug-options","title":"Help and debug options","text":"<pre><code>  -n, --dry-run\n            Do not write any files.\n  --batch, --not-interactive\n            Batch mode - disable interactive prompts.\n  --yes     Answer 'yes' or choose default to all interactive questions\n  -v, --verbose\n            Increase verbosity.\n  -q, --quiet\n            Less verbose output\n  -h, -?, --help\n            Show usage and exit.\n</code></pre>"},{"location":"cli/whl2conda-diff.html","title":"whl2conda diff","text":""},{"location":"cli/whl2conda-diff.html#whl2conda-diff","title":"whl2conda diff","text":""},{"location":"cli/whl2conda-diff.html#usage","title":"Usage","text":"<pre><code>usage: whl2conda diff [-h] -T &lt;tool&gt; [-A ...] &lt;conda-package&gt; &lt;conda-package&gt;\n</code></pre> <p>Compare the content of two conda packages</p> <p>This will unpack each conda packaeg into temporary directories, normalize the layout of files in the  input directory to minimize line differences, and will run the specified diff tool and arguments.</p> <p>This can be used to compare packages generated using this tool against those created using conda-build.</p>"},{"location":"cli/whl2conda-diff.html#positional-arguments","title":"positional arguments","text":"<pre><code>  &lt;conda-package&gt;\n            First package to compare\n  &lt;conda-package&gt;\n            Second package to compare\n</code></pre>"},{"location":"cli/whl2conda-diff.html#options","title":"options","text":"<pre><code>  -h, --help\n            show this help message and exit\n  -T &lt;tool&gt;, --diff-tool &lt;tool&gt;\n            Diff tool to use. This is currently required.\n\n            The tool is expected to take positional arguments\n            for each directory. Additional arguments may be\n            passed after --args.\n  -A ..., --args ...\n            All remaining arguments passed to diff tool\n</code></pre>"},{"location":"cli/whl2conda-install.html","title":"whl2conda install","text":""},{"location":"cli/whl2conda-install.html#whl2conda-install","title":"whl2conda install","text":""},{"location":"cli/whl2conda-install.html#usage","title":"Usage","text":"<pre><code>usage: whl2conda install (-p &lt;env-path&gt; | -n &lt;env-name&gt;) &lt;package-file&gt; [options]\n       whl2conda install --conda-bld &lt;package-file&gt; [options]\n</code></pre> <p>Install a conda package file</p> <p>This can be used to install a conda package file (generated by <code>whl2conda build</code>) either into a conda environment (for testing) or into your local conda build directory.</p>"},{"location":"cli/whl2conda-install.html#positional-arguments","title":"positional arguments","text":"<pre><code>  &lt;package-file&gt;\n            Conda package file to be installed\n            Must have extension .conda or .tar.bz2\n</code></pre>"},{"location":"cli/whl2conda-install.html#options","title":"options","text":"<pre><code>  -h, --help\n            show this help message and exit\n</code></pre>"},{"location":"cli/whl2conda-install.html#target-choose-one","title":"Target (choose one)","text":"<pre><code>  -p &lt;env-path&gt;, --prefix &lt;env-path&gt;\n            Path to target conda environment\n  -n &lt;env-name&gt;, --name &lt;env-name&gt;\n            Name of target conda enviroment\n  --conda-bld\n            Install into local conda-bld\n</code></pre>"},{"location":"cli/whl2conda-install.html#environment-options","title":"Environment options","text":"<pre><code>  These options can be used with -n/-p when install into\n  a conda environment. They are otherwise ignored.\n\n  --create  Create environment if it does not exist.\n  --only-deps\n            Only install package dependencies, not the package itself.\n  --mamba   Use mamba instead of conda for install actions\n  --extra ...\n            All the remaining arguments after this flat will be passed\n            to `conda install` or `conda create`. This can be used to add\n            additional dependencies for testing.\n</code></pre>"},{"location":"cli/whl2conda-install.html#common-options","title":"Common options","text":"<pre><code>  --dry-run\n            Display operations but don't actually install\n  --yes     Answer yes to prompts.\n</code></pre>"},{"location":"cli/whl2conda.html","title":"wl2conda","text":""},{"location":"cli/whl2conda.html#whl2conda","title":"whl2conda","text":""},{"location":"cli/whl2conda.html#usage","title":"Usage","text":"<pre><code>usage: whl2conda [options] &lt;command&gt; ...\n</code></pre> <p>Utility for building and testing conda package generated directly from a python wheel.</p> <p>See <code>whl2conda build --help</code> for more information.</p>"},{"location":"cli/whl2conda.html#options","title":"options","text":"<pre><code>  -h, --help\n            show this help message and exit\n  --version\n            show program's version number and exit\n</code></pre>"},{"location":"cli/whl2conda.html#commands","title":"Commands","text":"<pre><code>  &lt;command&gt;\n    config  configure whl2conda\n    convert\n            builds a conda package from a python wheel\n    diff    compare contents of conda packages\n    install\n            install conda package file with dependencies\n</code></pre>"}]}